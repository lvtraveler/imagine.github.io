<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="HTML5,缓存,性能," />





  <link rel="alternate" href="/atom.xml" title="Imagine" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="关于存储说道存储，你可能会想到这是服务器端的一种设置。
服务器端的存储介质大体上分为4种：

cache:缓存，它可以让从数据库、磁盘上输出的东西/数据放置在缓存里，从而减少数据库或是磁盘的读取与写入（IO）操作；
磁盘文件：如，我们常常会将图片、视频等文件存放在磁盘上；
数据库：mySql\mongoDB…关系\非关系数据库；
内存：通常放置频繁要使用到的东西，能够提高读取效率；缓存（cache">
<meta property="og:type" content="article">
<meta property="og:title" content="HTML5缓存的那些事">
<meta property="og:url" content="http://lvtraveler.github.io/2016/03/26/HTML5缓存的那些事/index.html">
<meta property="og:site_name" content="Imagine">
<meta property="og:description" content="关于存储说道存储，你可能会想到这是服务器端的一种设置。
服务器端的存储介质大体上分为4种：

cache:缓存，它可以让从数据库、磁盘上输出的东西/数据放置在缓存里，从而减少数据库或是磁盘的读取与写入（IO）操作；
磁盘文件：如，我们常常会将图片、视频等文件存放在磁盘上；
数据库：mySql\mongoDB…关系\非关系数据库；
内存：通常放置频繁要使用到的东西，能够提高读取效率；缓存（cache">
<meta property="og:image" content="http://lvtraveler.github.io/./img/h5_cache/cc01.png">
<meta property="og:image" content="http://lvtraveler.github.io/./img/h5_cache/cc03.png">
<meta property="og:image" content="http://lvtraveler.github.io/./img/h5_cache/cc04.png">
<meta property="og:image" content="http://lvtraveler.github.io/./img/h5_cache/cc05.png">
<meta property="og:updated_time" content="2016-04-03T13:25:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTML5缓存的那些事">
<meta name="twitter:description" content="关于存储说道存储，你可能会想到这是服务器端的一种设置。
服务器端的存储介质大体上分为4种：

cache:缓存，它可以让从数据库、磁盘上输出的东西/数据放置在缓存里，从而减少数据库或是磁盘的读取与写入（IO）操作；
磁盘文件：如，我们常常会将图片、视频等文件存放在磁盘上；
数据库：mySql\mongoDB…关系\非关系数据库；
内存：通常放置频繁要使用到的东西，能够提高读取效率；缓存（cache">
<meta name="twitter:image" content="http://lvtraveler.github.io/./img/h5_cache/cc01.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> HTML5缓存的那些事 | Imagine </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?e1728a0d233cdc31b7d6a7ba7d1be78f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Imagine</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'ukfWgk3L9zSEhKjpzZip','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                HTML5缓存的那些事
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-26T13:34:46+08:00" content="2016-03-26">
              2016-03-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/26/HTML5缓存的那些事/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/26/HTML5缓存的那些事/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="关于存储"><a href="#关于存储" class="headerlink" title="关于存储"></a>关于存储</h2><p>说道存储，你可能会想到这是服务器端的一种设置。</p>
<p>服务器端的存储介质大体上分为4种：</p>
<ul>
<li>cache:缓存，它可以让从数据库、磁盘上输出的东西/数据放置在缓存里，从而减少数据库或是磁盘的读取与写入（IO）操作；</li>
<li>磁盘文件：如，我们常常会将图片、视频等文件存放在磁盘上；</li>
<li>数据库：mySql\mongoDB…关系\非关系数据库；</li>
<li>内存：通常放置频繁要使用到的东西，能够提高读取效率；缓存（cache）也是存放在内存里的；</li>
</ul>
<h3 id="HTML的存储-cookies"><a href="#HTML的存储-cookies" class="headerlink" title="HTML的存储-cookies"></a>HTML的存储-cookies</h3><p>在HTML5出生之前，通常在浏览器（客户端）使用cookies来存储客户端的内容；</p>
<p>cookies的特点：</p>
<ul>
<li>每次的http请求头中，都会带有cookies——缺点；</li>
<li>每个域名只能存储4K大小的cookies;</li>
<li>主域名污染：如果我们使用cookies存储主域名的东西，那么子域名下得Http请求都会带上主域名的东西；</li>
</ul>
<p>如果关联上网络，那么将带来安全问题。</p>
<blockquote>
<p>所以，通常我们会使用cookies用在如购物车、身份验证等问题上。</p>
</blockquote>
<p>下面，我们来看一下百度首页的cookies在浏览器端的一个存储形态:</p>
<p>如图：</p>
<p><img src="./img/h5_cache/cc01.png" alt="alt text"></p>
<p>HTTP这一列，如果在setCookie的时候，这里就会打钩，这与HTTPOnly相关。</p>
<p>HTTPOnly：</p>
<p>如果把HTTPOnly设置为true,那么cookies只能被server服务器端来读取或是修改，客户端没有权限进行读取和修改。例如，我们在进行身份验证的时候，就可以使用这个。</p>
<p>Secure：与安全相关，如果设置了，那么请求只能是来自HTTP加密请求。</p>
<h3 id="HTML的存储-UserData"><a href="#HTML的存储-UserData" class="headerlink" title="HTML的存储-UserData"></a>HTML的存储-UserData</h3><ul>
<li>只有IE支持，有微软提供API，但不符合W3C标准；</li>
<li>存储在XML文件中；</li>
</ul>
<h3 id="HTML5的存储"><a href="#HTML5的存储" class="headerlink" title="HTML5的存储"></a>HTML5的存储</h3><p>针对以上问题，HTML5的出现，需要解决以下问题:</p>
<ul>
<li>解决4K的大小问题；</li>
<li>解决请求头常带存储信息的问题；</li>
<li>解决关系型存储的问题；</li>
<li>跨浏览器平台问题；</li>
</ul>
<p>##HTML5存储形式</p>
<ul>
<li>本地存储——localstorage \sessionstorage</li>
<li>离线缓存——application cache</li>
<li>IndexedDB、Web SQL</li>
</ul>
<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>API：</p>
<p>localstorage 、sessionstorage</p>
<p>存储形式：</p>
<p>key–&gt;value</p>
<p>过期时间：</p>
<p>localstorage:永久存储，永不失效，除非手动删除<br>sessionstorage:重新打开页面，或是关闭浏览器，sessionstorage才会消失；</p>
<p>存储大小：<br>每个域名能存5M；</p>
<p>支持情况：</p>
<p>IE8+,safari3.2+,chrome,firefox等主流浏览器都支持；</p>
<p>使用方法——localstorage\sessionstorage</p>
<p>主要涉及到5个方法：</p>
<ul>
<li>getItem:获取localstorage\sessionstorage</li>
<li>setItem:设置localstorage\sessionstorage</li>
<li>removeItem:移除localstorage\sessionstorage</li>
<li>key:获取某一个位置上的key值,按值从0开始索引；</li>
<li>clear:全部清除localstorage\sessionstorage</li>
</ul>
<p>例如：我们打开www.baidu.com</p>
<p>在控制台Console输出面板，输入：</p>
<p><code>localStorage.setItem(&quot;test1&quot;,&quot;test&quot;);</code><br>那么在Resources面板的Local Storage下，将出现Key=test1,value=test的记录</p>
<p><code>localStorage.getItem(&quot;test1&quot;);</code> //输出test</p>
<p><code>localStorage.key(0);</code>//输出BDSUGSTORED</p>
<p>sessionstorage的API与localstorage一样，但是你要注意一点：</p>
<p><strong>sessionStorage需要在浏览器关闭或是重新打开页面，才会消失；</strong></p>
<h3 id="本地存储可以存储什么？"><a href="#本地存储可以存储什么？" class="headerlink" title="本地存储可以存储什么？"></a>本地存储可以存储什么？</h3><ul>
<li>数组（需要将其序列化为字符串才能存储）；</li>
<li>json数据——将其转化为字符串存储；</li>
<li>图片</li>
<li>脚本、样式文件：通过ajax</li>
</ul>
<p>只要能被转化为字符串的数据，都能被localstorage存储；</p>
<h3 id="本地存储如何存储图片"><a href="#本地存储如何存储图片" class="headerlink" title="本地存储如何存储图片"></a>本地存储如何存储图片</h3><p>先来看一段代码：</p>
<pre><code>var src=&quot;demo.jpg&quot;;

function set(key){
    var img=document.createElement(&apos;img&apos;);

    img.addEventListener(&quot;load&quot;,function(){
        //创建一个canvas
        var imgCanvas=document.createElement(&quot;canvas&quot;),
        imgContext=imgCanvas.getContext(&quot;2d&quot;);
        //确保canvas元素的大小和图片的尺寸一致
        imgCanvas.width=this.width;
        imgCanvas.height=this.height;
        //渲染图片到canvas中,使用canvas的drawImage()方法
        imgContext.drawImage(this,0,0,this.width,this.height);
        //用canvas的dataUrl的形式取出图片,imgAsDataURL是一个base64的字符串
        var imgAsDataURL=imgCanvas.toDataURL(&quot;image/png&quot;);
        //保存到本地存储中
        //使用try-catch()查看是否支持localstorage
        try{
            localStorage.setItem(key,imgAsDataURL);//将取出的图片存放到localStorage 
        }
        catch(e) {
         console.log(&quot;Storage failed:&quot;+e);//存储失败
        }

    },false);
    img.src=src;
}    
function get(key) {//从本地缓存获取图片并且渲染
var srcStr=localStorage.getItem(key);//从localStorage中取出图片
var imgObj=document.createElement(&apos;img&apos;);//创建一个img标签
imgObj.src=srcStr;
document.body.appendChild(imgObj);
}

    注释：
    (1)、这个比较适合用在不常更改的图片，但是如果图片的base64大小比较大的话，将比较耗费localStorage的资源；

    (2)、canvas有一个安全策略的问题：如果图片和你本身请求的域名不在同一个域名下，浏览器会报出一个安全问题，这个时候我们要给我们的服务器加一个“允许跨域”访问的响应头————Access Orign=*,这样来保证你的图片可进行跨域被canvas来画；
</code></pre><h3 id="HTML5本地存储需要注意的："><a href="#HTML5本地存储需要注意的：" class="headerlink" title="HTML5本地存储需要注意的："></a>HTML5本地存储需要注意的：</h3><ul>
<li>使用前判断浏览器是否支持localStorage；（IOS浏览器在无痕模式浏览下，是无法打开localStorage；以及，其他奇葩浏览器，在存储localstorage的时候报错）</li>
</ul>
<p>做法：根据前面代码，我们在检查是否支持，先进行setItem()一次，然后对setItem进行异常捕获；</p>
<ul>
<li><p>写数据的时候，需要异常处理，避免超出容量抛出错误；<br>localStorage本身只有5M；</p>
</li>
<li><p>避免把敏感的信息存入localStorage；</p>
</li>
<li><p>key的唯一性；重复写，将会覆盖之前的key;</p>
</li>
</ul>
<h3 id="HTML5本地存储使用限制："><a href="#HTML5本地存储使用限制：" class="headerlink" title="HTML5本地存储使用限制："></a>HTML5本地存储使用限制：</h3><ul>
<li>存储更新策略，过期控制：localStorage是永不过期的，业务上如果想实现一些过期策略，需要在localStorage上加一层处理过期的机制；</li>
<li>各个子域名之间不能共享存储数据；（借助H5的postMessage()这个API做一些跨域上得处理）</li>
<li>超出存储大小之后如何存储——使用一些如LRU、FIFO的算法去淘汰一些旧的数据；</li>
<li>server端如何取到数据——使用post/get参数</li>
</ul>
<h3 id="处理过期控制"><a href="#处理过期控制" class="headerlink" title="处理过期控制"></a>处理过期控制</h3><p>先来看一下代码：</p>
<pre><code>function set(key,y){
    var curTime=new Date().getTime();
    //存储一个当时存储时候的时间
    localStorage.setItem(key,JSON.stringify({data:v,time:curTime}));

}
function get(key,exp) {
    var data=localStorage.getItem(key);
    var dataObj=JSON.parse(data);
    if(new Date().getTime()-dataObj.time&gt;exp) {//get出来的时间减去当时存储的时间大于过期时间，那么就认为过期
       console.log(&quot;过期&quot;);
    }else {
    //否则，返回值
     console.log(&quot;data=&quot;+dataObj.data);
    }
}
</code></pre><h3 id="本地存储使用场景"><a href="#本地存储使用场景" class="headerlink" title="本地存储使用场景"></a>本地存储使用场景</h3><ul>
<li>本地数据存储，减少网络传输</li>
<li>在弱网络的环境下，会发生高延迟，低带宽，应该尽量把数据（如脚本、样式）本地化；</li>
</ul>
<p>我们来看一张图，显示的是本地存储和网络拉取耗时的对比：</p>
<p><img src="./img/h5_cache/cc03.png" alt="alt text"></p>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>IndexedDB,是一种能做浏览器中持久地存储结构化数据的数据库，并且为web应用提供了丰富的查询能力；</p>
<h3 id="支持情况"><a href="#支持情况" class="headerlink" title="支持情况"></a>支持情况</h3><p>chrome11+\opera不支持\firefox 4+\IE 10+,移动端浏览器支持能力弱</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>IndexedDB是按域名分配独立空间，一个独立域名下可以创建多个数据库，每个数据库可以创建对个对象存储空间（表/table）,一个对象存储空间可以存储多个对象数据；</p>
<p>如图：</p>
<p><img src="./img/h5_cache/cc04.png" alt="alt text"></p>
<h3 id="使用IndexedDB实现离线数据库"><a href="#使用IndexedDB实现离线数据库" class="headerlink" title="使用IndexedDB实现离线数据库"></a>使用IndexedDB实现离线数据库</h3><p>这里我们主要从IndexedDB 的四大功能入手：</p>
<ul>
<li>增删改</li>
<li>事务处理</li>
<li>游标</li>
<li>索引</li>
</ul>
<p>下面我们通过一段代码来讲解，请关注里面的注释：</p>
<pre><code> &lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;div class=&quot;form-group&quot;&gt;
    &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;&quot; /&gt;    
    &lt;label for=&quot;phone&quot;&gt;电话：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;phone&quot; value=&quot;&quot; /&gt;    
    &lt;label for=&quot;address&quot;&gt;地址:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;address&quot; value=&quot;&quot; /&gt;    
    &lt;input type=&quot;button&quot; id=&quot;seletBtn&quot; value=&quot;查询&quot; /&gt;    
    &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt;    
    &lt;input type=&quot;button&quot; id=&quot;deleteDB&quot; value=&quot;删除数据库&quot; /&gt;    
&lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    var db;
    var arrayKey=[];
    var openRequest;
    var lastCursor;
    var indexedDB=window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;//indexedDB在不同的浏览器下不同

    var dbName=&quot;person&quot;;//数据库名称
    var tableName=&quot;testTable&quot;;//表名称
    function init() {
        openRequest=indexedDB.open(dbName);//页面加载时先打开一个DB，如果该DB存在，则打开；不存在，则新建

        //触发事件——当一个“新的数据库”被创建或者数据库的“版本号”被更改时触发
        openRequest.onupgradeneeded=function(e){
            console.log(&quot;onupgradeneeded&quot;);
            var thisDb=e.target.result;
            console.log(thisDb.version);

            //检查这个数据库中是否包含我们要查找的表
            if(!thisDb.objectStoreNames.contains(tableName)){
                //不包含——创建一个表
                console.log(&quot;需要创建一个objectStore&quot;);
                //keyPath:主键，autoIncrement：主键自增
                var objectStore=thisDb.createObjectStore(tableName,{keyPath:&quot;id&quot;,autoIncrement:true});
                //创建表的时候，指定哪些字段是能被索引的
                objectStore.createIndex(&quot;name&quot;,&quot;name&quot;,{unique:false});//创建索引
                objectStore.createIndex(&quot;phone&quot;,&quot;phone&quot;,{unique:false});
            }

        }
        //触发事件——成功打开一个数据库时触发
        openRequest.onsuccess=function(e){
            db=e.target.result;
            console.log(db.version);
            db.onerror=function(event){
                alert(&quot;数据库错误:&quot;+event.target.errorCode);
                console.dir(event.target);
            };
            //判断该数据库中有没有这个表
            if(db.objectStoreNames.contains(tableName)){
                //存在这个表
                console.log(&quot;包含表：&quot;+tableName);
                //通过事物机制操作一个表的读写，从而保证数据的一致性和可靠性
                var transaction=db.transaction([tableName],&quot;readwrite&quot;);
                //事物的事件
                transaction.oncomplete=function(event){
                    console.log(&quot;完成&quot;);
                };

                transaction.onerror=function(event){
                    console.dir(event);
                };
                var objectStore=transaction.objectStore(tableName);//通过事物获取表中一个objectStore对象,即表的对象

                //遍历表的记录——游标-openCursor,这是indexedDb的重点
                objectStore.openCursor().onsuccess=function(event){
                    var cursor=event.target.result;
                    if(cursor){
                        console.log(cursor.key);
                        console.dir(cursor.value);
                        render({key:cursor.key,name:cursor.value[&quot;name&quot;],phone:cursor.value[&quot;phone&quot;],address:cursor.value[&quot;address&quot;]});
                        lastCursor=cursor.key;//如果不设置lastCursor,那么游标默认是下一条接着下一条来遍历；设置了lastCursor,游标将循环遍历
                        cursor.continue();
                    }else {
                        console.log(&quot;请使用游标来搞定&quot;);
                    }
                };
                objectStore.openCursor().onerror=function(event){
                    console.dir(event);
                };

            }

        }


        //添加新记录
        document.querySelector(&quot;#add&quot;).addEventListener(&quot;click&quot;,function(){
            var name=document.querySelector(&quot;#name&quot;).value();
            var phone=document.querySelector(&quot;#phone&quot;).value();
            var address=document.querySelector(&quot;address&quot;).value();
            var person={&quot;name&quot;:name,&quot;phone&quot;:phone,&quot;address&quot;:address};//设置对象
            //通过事务——操作表
            var transaction=db.transaction([tableName],&quot;readwrite&quot;);
            transaction.oncomplete=function(event){
                console.log(&quot;事务处理完成&quot;);
            };
            transaction.onerror=function(event){
                console.dir(event);
            };
            var objectStore=transaction.objectStore(tableName);//创建一个表对象
            objectStore.add(person);//添加对象到表中——add()
            //将新增的记录显示处理
            objectStore.openCursor().onsuccess=function(event){
                cursor=event.target.result;
                var key;
                if(lastCursor==null){
                    key=cursor.key;
                    lastCursor=key;
                }else {
                    key=++lastCursor;
                }
                render({key:key,name:name,phone:phone,address:address});
                console.log(&quot;成功添加新记录:&quot;+key);
                console.dir(person);
            }

        });

        //删除指定ID
        function deleteRecord(id){
            var transaction=db.transaction([tableName],&quot;readwrite&quot;);
            transaction.oncomplete=function(event){
                console.log(&quot;事务处理完成&quot;);
            };
            transaction.onerror=function(event){
                console.dir(event);
            };
            var objectStore=transaction.objectStore(tableName);
            var removeKey=parseInt(id);
            var getRequest=objectStore.get(removeKey);//获取索引值---get()
            getRequest.onsuccess=function(e){
                var result=getRequest.result;
                console.dir(result);
            }
            var request=objectStore.delete(removeKey);//删除——delete
            request.onsuccess=function(e){
                console.log(&quot;删除成功&quot;);
            };
            request.onerror=function(e){
                console.log(&quot;删除错误&quot;+e);
            };
            //隐藏删除的DOM
            document.getElementById(removeKey).style.display=&quot;none&quot;;
        }

        //查询记录
        document.querySelector(&quot;#seletBtn&quot;).addEventListener(&quot;click&quot;,function(){
            var curName=document.getElementById(&quot;selname&quot;).value；
            var transaction=db.transaction([tableName],&quot;readwrite&quot;);
            transaction.oncomplete=function(event){
                console.log(&quot;事务处理完成&quot;);
            };
            transaction.onerror=function(event){
                console.dir(event);
            };
            var objectStore=transaction.objectStore(tableName);
            var boundKeyRange=IDBKeyRange.only(curName);//生成一个表示范围的Range对象---IDBKeyRange,有4个方法，only\lowerBound\upperBound\bound
            objectStore.index(&quot;name&quot;).openCursor(boundKeyRange).onsuccess=function(event){
                //从indexedDb中找到name
                var cursor=event.target.result;
                if(!cursor){
                    return;
                }
                var rowData=cursor.value;
                console.log(rowData);
                document.getElementById(&apos;content&apos;).innerHTML=&quot;&quot;;
                render({key:cursor.value.id,name:cursor.value[&quot;name&quot;],phone:cursor.value[&quot;phone&quot;],address:cursor.value[&quot;address&quot;]});
                cursor.continue();
            };

        });
        //删除数据库
        document.querySelector(&quot;#deleteDB&quot;).addEventListener(&quot;click&quot;,function(){
            //使用deleteDatabase()
            var deleteDB=indexedDB.deleteDatabase(dbName);
            var content=document.querySelector(&quot;#content&quot;);
            while(content.firstChild){
                content.removeChild(content.firstChild);
            }
            deleteDB.onsuccess=function(event){
                console.log(&quot;删除成功&quot;);
            };
            deleteDB.onerror=function(event){
                console.dir(event.target);
            };
        });

        //渲染
        function render(opt){
            var child_node = document.createElement(&quot;div&quot;);
            var child_node_child1 = document.createElement(&quot;div&quot;);
            var child_node_child2 = document.createElement(&quot;div&quot;);
            var child_node_child3 = document.createElement(&quot;div&quot;);
            var child_node_child4 = document.createElement(&quot;div&quot;);
            child_node_child1.setAttribute(&quot;class&quot;,&quot;table_child&quot;);
            child_node_child2.setAttribute(&quot;class&quot;,&quot;table_child&quot;);
            child_node_child3.setAttribute(&quot;class&quot;,&quot;table_child&quot;);
            child_node_child4.setAttribute(&quot;class&quot;,&quot;table_child&quot;);
            child_node_child1.setAttribute(&quot;style&quot;,&quot;float:left&quot;);
            child_node_child2.setAttribute(&quot;style&quot;,&quot;float:left&quot;);
            child_node_child3.setAttribute(&quot;style&quot;,&quot;float:left&quot;);
            child_node_child4.setAttribute(&quot;style&quot;,&quot;float:left&quot;);
            child_node_child1.innerHTML = name;
            child_node_child2.innerHTML = opt.phone;
            child_node_child3.innerHTML = opt.address;
            child_node_child4.innerHTML = &quot;&lt;input type=&apos;button&apos; value=&apos;删除&apos;&gt;&quot;
            child_node.appendChild(child_node_child1);
            child_node.appendChild(child_node_child2);
            child_node.appendChild(child_node_child3);
            child_node.appendChild(child_node_child4);
            child_node.setAttribute(&quot;class&quot;,&quot;table_tr&quot;);
            child_node.setAttribute(&quot;id&quot;,opt.key);
            var content = document.getElementById(&apos;content&apos;);
            content.appendChild(child_node)

        }

    }
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="离线缓存——application-Cache"><a href="#离线缓存——application-Cache" class="headerlink" title="离线缓存——application Cache"></a>离线缓存——application Cache</h2><h3 id="何为离线缓存"><a href="#何为离线缓存" class="headerlink" title="何为离线缓存"></a>何为离线缓存</h3><blockquote>
<p>它是能让web应用在离线的情况下继续使用，通过一个叫manifest的文件指明需要缓存的资源；你可以通过<code>navigator.online</code>检测是否在线；</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如图：</p>
<p><img src="./img/h5_cache/cc05.png" alt="alt text"></p>
<p>解释：</p>
<p>（1）用户通过浏览器（browser）去访问应用，首先检测浏览器是否有一个叫做“App cache”的东西存在，如果存在，则从中检索出app cache所要缓存的list,然后把资源（缓存在浏览器中）拉取出来，返回给用户；</p>
<p>（2）在访问的同时，会检查server上一个叫做manifest的文件，如果该文件有更新，就把manifest指定的文件从server端重新拉取一次，然后把这些缓存在浏览器中，并更新相应的app cache文件；如果manifest这个文件没有更新，那么就啥也不做。</p>
<p>从上图，我们总结2点：</p>
<ul>
<li>缓存机制的改变，会更新app cache.但是，用户访问，会返回上一次的结果。这样一来，会有一个麻烦，即如果你的业务发生更改，你就需要去更新一次manifest。</li>
</ul>
<p>注意：更改完，第一次是不生效的，只有第二次刷新才会生效；</p>
<ul>
<li>如果有一个文件要更新，你就要去更新manifest,而更新manifest文件，它会把server上的文件全部重新拉取一次，而非只是拉取你需要更改的那个文件，这就会造成损耗；</li>
</ul>
<h3 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h3><p>safari on ios 3.2+\android 1,5+\window phone 9+</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>例子：cache.appcache</p>
<pre><code>CACHE MANIFEST

#version 1.0

CACHE:

#需要缓存的文件
/css/a.css
/js/a/js
/images/a.png

NETWORK:

#每次重新拉取的文件

*

FALLBACK

#离线状况下代替的文件

/404.html
</code></pre><p>在页面上引入manifest文件:</p>
<p><code>&lt;html manifest=&quot;cache.appcache&quot;&gt;</code></p>
<p>在服务器添加<code>mime-type text/cache-manifest</code></p>
<p>如果在服务器上添加：</p>
<p>找到你的xampp/apache/conf目录,找到mime.types文件，在最后面添加一条记录：</p>
<p><code>text/cache-manifest  appcache</code>   （appcache是后缀名，你可以选择其他的）</p>
<p>我们来看一个例子：</p>
<pre><code>&lt;html lang=&quot;en&quot; manifest=&quot;cache.appcache&quot;&gt;
  &lt;head&gt;
    &lt;meat charset=&quot;utf-8&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
     &lt;h1&gt;&lt;demo1/h1&gt;

  &lt;script type=&quot;text/javascript&quot;&gt;
    window.addEventListener(&apos;load&apos;,function(e){
    //监听app cache的updateready事件
     window.applicationCache.addEventListener(&apos;updateready&apos;,function(e)){

        console.log(window.applicationCache.status);
        if(window.applicatioinCache.status==window.applicationCache.UPDATEREADY){
        //application cache的版本号发生改年
          window.applicationCache.swapCache();
          window.location.reload();
        }else {
          console.log(&quot;manifest没有更改&quot;);
        }
    },false);
  },false);
  &lt;/script&gt;
  &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>注意：</p>
<ul>
<li><p>app cache会自动地将本页当做一个静态页缓存；</p>
</li>
<li><p>如果你要更新，请更新server端的manifest文件的版本；</p>
</li>
<li><p>如果你不想启用app cache,或者说现在app cache不适合你现在的应用，那么有一个做法：</p>
</li>
</ul>
<p>更改server端上manifest文件的名称，例如<code>cache1.appcache</code>,这个时候再去刷新浏览器，首先，浏览器还是会从app cache缓存中读取缓存，到第二次刷新的时候，浏览器会到server端查找manifest文件，发现这个文件不存在，那么浏览器会走网络从Server上重新拉取文件；</p>
<h3 id="app-cache优势："><a href="#app-cache优势：" class="headerlink" title="app cache优势："></a>app cache优势：</h3><ul>
<li>完全离线</li>
<li>资源缓存，加载更快</li>
<li>降低服务器负载</li>
</ul>
<h3 id="app-cache缺陷："><a href="#app-cache缺陷：" class="headerlink" title="app cache缺陷："></a>app cache缺陷：</h3><ul>
<li>含有manifest属性的当前请求页无论如何都会被缓存；</li>
<li>更新需要建立在manifest文件的更新，文件更新后是需要页面再次刷新的，并且在第2次刷新才能获取新资源；</li>
<li>更新是全局性的，无法单独更新某个文件；</li>
<li>对于链接的参数变化的敏感的，任何一个参数的修改都会被重新缓存，例如：index.html和index.html?v=1会被认为是不同文件，分别缓存；</li>
</ul>
<h3 id="app-cache适用场景"><a href="#app-cache适用场景" class="headerlink" title="app cache适用场景"></a>app cache适用场景</h3><ul>
<li>单地址页面</li>
<li>对实时性要求不要的业务</li>
<li>离线web应用</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际应用中，我们需要根据业务的需要来采取相应的缓存措施，如上所述，html5的几种缓存都有各自的优缺点和适用场景，有时我们也需要组合使用。</p>
<p>关于HTML5缓存我们就介绍到这里。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://rainsilence.iteye.com/blog/984569" target="_blank" rel="external">HTML5之IndexedDB使用详解</a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/HTML5/" rel="tag">#HTML5</a>
          
            <a href="/tags/缓存/" rel="tag">#缓存</a>
          
            <a href="/tags/性能/" rel="tag">#性能</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/20/【01】前端开发环境配置/" rel="next" title="fis-plus【01】——前端开发环境配置">
                <i class="fa fa-chevron-left"></i> fis-plus【01】——前端开发环境配置
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/09/分成两半的子爵/" rel="prev" title="《分成两半的子爵》">
                《分成两半的子爵》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/03/26/HTML5缓存的那些事/"
     data-title="HTML5缓存的那些事"
     data-content=""
     data-url="http://lvtraveler.github.io/2016/03/26/HTML5缓存的那些事/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/03/26/HTML5缓存的那些事/"
           data-title="HTML5缓存的那些事" data-url="http://lvtraveler.github.io/2016/03/26/HTML5缓存的那些事/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar2.png"
               alt="imagineXie" />
          <p class="site-author-name" itemprop="name">imagineXie</p>
          <p class="site-description motion-element" itemprop="description">this is imagine life</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lvtraveler" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/imaginecode" target="_blank">
                  
                    <i class="fa fa-coffee"></i> csdn
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
            <div class="links-of-blogroll-title">Links</div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.babybus.com/plus/" target="_blank">bbplus</a>
                </li>
              
            </ul>
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于存储"><span class="nav-number">1.</span> <span class="nav-text">关于存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML的存储-cookies"><span class="nav-number">1.1.</span> <span class="nav-text">HTML的存储-cookies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML的存储-UserData"><span class="nav-number">1.2.</span> <span class="nav-text">HTML的存储-UserData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5的存储"><span class="nav-number">1.3.</span> <span class="nav-text">HTML5的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地存储"><span class="nav-number">1.4.</span> <span class="nav-text">本地存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地存储可以存储什么？"><span class="nav-number">1.5.</span> <span class="nav-text">本地存储可以存储什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地存储如何存储图片"><span class="nav-number">1.6.</span> <span class="nav-text">本地存储如何存储图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5本地存储需要注意的："><span class="nav-number">1.7.</span> <span class="nav-text">HTML5本地存储需要注意的：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5本地存储使用限制："><span class="nav-number">1.8.</span> <span class="nav-text">HTML5本地存储使用限制：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理过期控制"><span class="nav-number">1.9.</span> <span class="nav-text">处理过期控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地存储使用场景"><span class="nav-number">1.10.</span> <span class="nav-text">本地存储使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IndexedDB"><span class="nav-number">2.</span> <span class="nav-text">IndexedDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持情况"><span class="nav-number">2.2.</span> <span class="nav-text">支持情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储结构"><span class="nav-number">2.3.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用IndexedDB实现离线数据库"><span class="nav-number">2.4.</span> <span class="nav-text">使用IndexedDB实现离线数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离线缓存——application-Cache"><span class="nav-number">3.</span> <span class="nav-text">离线缓存——application Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#何为离线缓存"><span class="nav-number">3.1.</span> <span class="nav-text">何为离线缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">3.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器支持情况"><span class="nav-number">3.3.</span> <span class="nav-text">浏览器支持情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用"><span class="nav-number">3.4.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#app-cache优势："><span class="nav-number">3.5.</span> <span class="nav-text">app cache优势：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#app-cache缺陷："><span class="nav-number">3.6.</span> <span class="nav-text">app cache缺陷：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#app-cache适用场景"><span class="nav-number">3.7.</span> <span class="nav-text">app cache适用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">imagineXie</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"imagineXie"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
